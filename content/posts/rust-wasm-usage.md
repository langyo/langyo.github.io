+++
title="基于 Rust 的 WebAssembly 使用指南"
date=2024-05-27
draft=false
+++

时隔许久，尽管我已经在此期间成功上线了好几个纯 Rust 编写的 Web 服务，但一直没能抽空整理与此相关的基础设施的入门指南。不同于隔壁 JavaScript 娱乐圈每天都能有人整活，Rust 这边不论是要做浏览器还是 WebAssembly 的基础设施都还是非常缺人的，自然也就没有卖课的去关注这方面内容。索性，我决定就如何以 Rust 在浏览器中实现异步操作做个简单的知识梳理。

老实说，[MDN 上的那篇教程](https://developer.mozilla.org/en-US/docs/WebAssembly)其实已经有点过时了，但这是 Rust 这里的基础设施更新太快太激进导致的。我这次写这篇博客就是为了应对这种情况，不要纠结于过时的教程。

## 1. `WebAssembly` 的背景

## 2. 什么是 `wasm_bindgen`？

## 3. 与浏览器直接交互的包装接口 `web_sys` 与 `js_sys`

## 4. 异步支持 `wasm_bindgen_futures`

## 5. 过去的 `wasm-pack` 与现在的 `trunk`

## 6. 手动编译打包手段 `wasm-bindgen-cli`

## 7. 以类似 `React` 的渲染库 `yew` 构建界面

## 8. 以类似 `imgui` 的库 `egui` 构建界面

## 9. 来自未来的 `WASI`

## 10. `wasmtime`、`wasmedge`、`wasmer` 三家分晋

三家从其路线上可以分别看作 “学院派”、“实干派”、“实验派”，有点像温竣岩刚出的那个纺织业的纪录片中北京维尼纶厂在建设初期和日本合作拉来的团队组成。

`wasmtime` 更倾向于严格遵循标准，毕竟 `WASI` 标准也是主要由这个团队起草的，但也因此这位的产出是最慢的，一天到晚都在开会。不过他们手里同时也有至今最有发展潜力的纯 Rust 写的编译器后端之一 `cranelift`，另外两家想踢了他是想都别想的事情。

`wasmedge` 更倾向于快速投入商业使用，到处寻求合作，甚至已经和 Docker 官方达成战略合作，Docker 可以直接部署基于 `wasmedge` 的容器。不过它是 C++ 写的，并且有很多私货，在遵守 `WASI` 基本规范的同时自行加了很多东西。

`wasmer` 更倾向于将其做得更有利于工程化，保证上游链路可以按原样直接用，为此甚至不惜代价重写了一直蔓延到 `rustc` 编译器本身的代码。但也因此魔改的过于剧烈，直接导致其维护的大量上游分支产能跟不上社区，有点割裂。但是 `wasmer` 率先做了 WASI 中心库的设施，所以一时间大家对此也很看好。
