# JavaScript 函数式编程 知识点笔记

- 函数式编程中纯函数的特征
  - 函数必须总是接受至少一个参数（提倡有且只有一个参数）
  - 函数必须总是返回一个值
  - 函数应该完全依赖接收到的参数（以及由函数闭包特性保存的上下文），而不能依赖外部环境（例如全局变量、IO）执行
  - 函数的每个有效输入必须有且只有唯一一个与之对应的输出

- 纯函数的定义
给定一个输入，其总是返回相同的输出。

- 在 JavaScript 中，函数是一等公民，可直接作为变量进行传递。

- 闭包
闭包指在一个函数的内部创建一个函数，此函数在被创建时会自动储存其所在位置的上下文。

本质上，闭包的过程是外部函数将其所创建的所有局部变量引用交给创建的新函数的过程。而且需要注意，即使外科函数已经全部执行完成，只要其创建的内部函数还存在，你就仍可以通过此内部函数访问其原本的早已执行完成的外部函数所定义的局部变量，这些局部变量的值在外部函数执行完后仍会保留并提供给内部函数使用。

与闭包机制类似但实现不同的是数据结构体，通过同事为数据结构体定义既定的常量参数与需要用到它们的成员函数（方法），也能做到与闭包一样的效果。

- 变参函数
在 JavaScript 中也可以定义变参参数，即使在 ES6 前已经有一个在函数体内自动由语言执行引擎创建的全局变量 arguments。

```javascript
const variadic = (a, ...variadic) => {
    console.log(a);         // 输出 a 本身的值
    console.log(variadic);  // 输出一个带有剩余参数的数组
}
variadic(1, 2, 3);
/*
    输出：
    1
    [2, 3]
*/
```

- 柯里化的定义
柯里化(currying)是把一个多参数函数转换为一个嵌套的一元函数的过程。

例如，有一个含三个参数的函数：

```javascript
const add = (x, y, z) => x + y + z;
```

对它柯里化后应当为这样：

```javascript
const addCurried = x => y => z => x + y + z;
```

由此带来的调用方式上的改变如下所示：

```javascript
// 原本的调用方式
add(1, 2, 3);
// 柯里化后的调用方式
addCurried(1)(2)(3);
```

能够在 JavaScript 中实现柯里化的两条非常重要的语言特性，分别是闭包与可变参数。

柯里化最主要的用途，是将参数复杂、功能庞大的函数打包为简单、便捷、易用、参数较少的高阶函数，这是简化大型项目代码时需要使用的必备工具之一。

- 偏应用的定义
偏应用(partial application)是把一个多参数函数的各个参数选择赋予默认值，以这些默认值将原本的函数打包为一个新的高阶函数。由于新的函数设置了对原函数部分参数（通常是末尾的参数），因此在调用包装好的高阶函数后就可以不用重复写哪些已有默认值的参数了。

```javascript
const setTimeoutTemMs = partial(setTimeout, undefined, 10);
// 等同于 fn => setTimeout(fn, 10);
```

以上代码便设定了末尾参数的默认值，并凭此打包成一个新的高阶函数，由原本需要 2 个参数变为了只要前一个，而后一个则自动填充为 10。

- 组合与管道
组合(compose)与关道(pipeline)实际上在做同一件事情，它们都用于实现函数与函数间的衔接，一个函数的输出（返回值）直接作为下一个函数的输入（参数）。

对于纯函数的组合，它满足结合律：

```javascript
compose(f, compose(g, h)) == compose(compose(f, g), h);     // true，执行顺序为 h, g, f
pipe(pipe(a, b), c) == pipe(a, pipe(b, c));                 // true，执行顺序为 a, b, c
```

组合与管道的区别仅在于数据流，它们正好相反，compose 从右往左执行，pipe 从左往右执行：

```javascript
let splitInfoSpaces = str => str.split("");
let count = arr => arr.length;
compose(count, slitInfoSpaces) == pipe(splitInfoSpaces, count);     // ture
```

由 compose 或 pipe 构造得到的高阶函数接收一个参数，作为这批函数流头部的输入。

```javascript
compose(count, splitInfoSpaces)("Hello, world!") === pipe(splitInfoSpaces, count)("Hellp, world!");     // true
```

- 函子的定义
函子是一个普通对象（在其它语言中，可能是一个类或对象），它重新实现了 map 函数，使得其在遍历每个对象值的时候生成一个新对象。

上述的解释刚开始看可能会有点迷糊，但随着下面的举例，你将能从感性上理解函子的实际用法，进而理解函子的工作原理与本质。

使用函子的目的主要是为完全以纯函数处理错误，而无需依赖命令式的抛出 - 捕捉方式(try - throw- catch)。

  - 容器(Container)
  任何函子都依赖（或也可以理解为继承）一个可以存储值的容器，每个容器都具有一个 value 属性，用于存储这个容器持有的值。
